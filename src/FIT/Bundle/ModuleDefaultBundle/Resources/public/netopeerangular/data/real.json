{
  "netopeer-cfgnetopeer:netopeer": {
    "tls": {
      "server-cert": "MIID+TCCAuGgAwIBAgIBAjANBgkqhkiG9w0BAQUFADCBjDELMAkGA1UEBhMCQ1ox\nFjAUBgNVBAgMDVNvdXRoIE1vcmF2aWExDTALBgNVBAcMBEJybm8xDzANBgNVBAoM\nBkNFU05FVDEMMAoGA1UECwwDVE1DMRMwEQYDVQQDDApleGFtcGxlIENBMSIwIAYJ\nKoZIhvcNAQkBFhNleGFtcGxlY2FAbG9jYWxob3N0MB4XDTE0MDcyNDE0MzI0NVoX\nDTE1MDcyNDE0MzI0NVowdjELMAkGA1UEBhMCQ1oxFjAUBgNVBAgMDVNvdXRoIE1v\ncmF2aWExDzANBgNVBAoMBkNFU05FVDEMMAoGA1UECwwDVE1DMQ8wDQYDVQQDDAZz\nZXJ2ZXIxHzAdBgkqhkiG9w0BCQEWEHNlcnZlckBsb2NhbGhvc3QwggEiMA0GCSqG\nSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx0jVMGPNfU+BBcW48LDn+RDBTuqSuGKsx\nwUBeEjwShd6k9r18oBW4yMdbfY\/qc3MOmeEV7RgZ02WggQ3eEknztxU6qPijvNkx\nurfNUbYvwCzsxMDy1hebZ9IL\/SsjHFFF6ZwZRczSr7gsQAKNmPak4qidqK8XlVuG\nA2M8I7UmP9NqZRzRpWITnvsL0v0SI5sYz5sZtptaT8pYouy\/FRz6wpldonumxNWC\nmCAkCRSzOWbA5CAWIxJHncT38ICRBiHMZUKYfjhWzofOzdFmM5Ntx7jCviieCIDk\nts95I1IIWPL2WgqloTWu06OQ0FV2I08JBOYu44NdRMqCR4v72\/87AgMBAAGjezB5\nMAkGA1UdEwQCMAAwLAYJYIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENl\ncnRpZmljYXRlMB0GA1UdDgQWBBTzeoS1AMXMO8uhogi+qJTqTuPW6zAfBgNVHSME\nGDAWgBRzVhAiqNmwdXCV5rQAHg36KU0jaDANBgkqhkiG9w0BAQUFAAOCAQEAnyBQ\nx\/5caVqR2S0kBD8VG4BER5mIk3biDY2urzKHVG2GubvsFgrct1+vDUToFHyYwZtP\neRBORApiugqIP2WhKTIs1SDJ41X4IDnT\/ChNpZ89b31zja1TnuJTzTdXEebBGkb9\nns98BH8Tg2+QIFcNB0eXqIiG5HG++MVoc4WzKB12fvfVJHKm9iHPpAC+EyTVScVv\nL5otbwVhwp0MiaMDjEqoUJEbrT4JhtZh1BgCXzhw7LcNOD8Ukr6Q1uRue\/jjpJbC\nN6ofbnrSras5tJH9QWaW6tT5iDdIlKPExfrwHUqC4YHO0+3Q15yttwfh7wCwNU2H\ndP4VfSRdn\/LaTmR68Q==",
      "server-key": {
        "key-data": "MIIEowIBAAKCAQEAsdI1TBjzX1PgQXFuPCw5\/kQwU7qkrhirMcFAXhI8EoXepPa9\nfKAVuMjHW32P6nNzDpnhFe0YGdNloIEN3hJJ87cVOqj4o7zZMbq3zVG2L8As7MTA\n8tYXm2fSC\/0rIxxRRemcGUXM0q+4LEACjZj2pOKonaivF5VbhgNjPCO1Jj\/TamUc\n0aViE577C9L9EiObGM+bGbabWk\/KWKLsvxUc+sKZXaJ7psTVgpggJAkUszlmwOQg\nFiMSR53E9\/CAkQYhzGVCmH44Vs6Hzs3RZjOTbce4wr4ongiA5LbPeSNSCFjy9loK\npaE1rtOjkNBVdiNPCQTmLuODXUTKgkeL+9v\/OwIDAQABAoIBAG\/4MG1JbL4C\/7vV\npBcpth7Aaznd1eJ2UB4VVOWnT8JOH2L6p1h5KRRhAP9AMkXsCnAQPyZiVAG3FlAZ\n01SZaY2YJDr6uQ3JVW4155TWtgSdWux\/\/Ass+lJ17lJ0SRxjsV13ez6CsDWeRjc+\n2xy0S+KJgqk71XzhJG9fZLYyuddp3U\/i3xFPUAcQM9xXKxcaD7g6LJf+a9pt6rim\nEqq\/pjJxDgTsRLARsazYuxrlOB445mvnLiYhOf2\/MvI80jIUKaj8BeAhg49UIg\/k\nmIh0xdevkcxBFer\/BjBjscWaFjx14D6nkFMw7vtCum5KfalLN2edZKAzByOudGD4\n5KnRp3ECgYEA6vnSoNGg9Do80JOpXRGYWhcR1lIDO5yRW5rVagncCcW5Pn\/GMtNd\nx2q6k1ks8mXKR9CxZrxZGqeYObZ9a\/5SLih7ZkpiVWXG8ZiBIPhP6lnwm5OeIqLa\nhr0BYWcRfrGg1phj5uySZgsVBE+D8jH42O9ccdvrWv1OiryAHfKIcwMCgYEAwbs+\nHfQtvHOQXSYNhtOeA7IetkGy3cKVg2oILNcROvI96hS0MZKt1Rko0UAapx96eCIr\nel7vfdT0eUzNqt2wTKp1zmiG+SnX3fMDJNzMwu\/jb\/b4wQ20IHWNDnqcqTUVRUnL\niksLFoHbTxsN5NpEQExcSt\/zzP4qi1W2Bmo18WkCgYEAnhrk16LVux9ohiulHONW\n8N9u+BeM51JtGAcxrDzgGo85Gs2czdwc0K6GxdiN\/rfxCKtqgqcfCWlVaxfYgo7I\nOxiwF17blXx7BVrJICcUlqpX1Ebac5HCmkCYqjJQuj\/I6jv1lI7\/3rt8M79RF+j5\n+PXt7Qq97SZd78nwJrZni4MCgYAiPjZ8lOyAouyhilhZvI3xmUpUbMhw6jQDRnqr\nclhZUvgeqAoxuPuA7zGHywzq\/WVoVqHYv28Vjs6noiu4R\/chlf+8vD0fTYYadRnZ\nKi4HRt+sqrrNZN6x3hVQudt3DSr1VFXl293Z3JonIWETUoE93EFz+qHdWg+rETtb\nZuqiAQKBgD+HI\/syLECyO8UynuEaDD7qPl87PJ\/CmZLMxa2\/ZZUjhaXAW7CJMaS6\n9PIzsLk33y3O4Qer0wx\/tEdfnxMTBJrgGt\/lFFdAKhSJroZ45l5apiavg1oZYp89\njSd0lVxWSmrBjBZLnqOl336gzaBVkBD5ND+XUPdR1UuVQExJlem4",
        "key-type": "RSA",
        "$@key-data": {
          "eltype": "leaf",
          "description": "Server private key (in base64-encoded DER) matching\n the server certificate.",
          "config": true,
          "status": "current",
          "mandatory": true,
          "type": "binary",
          "iskey": false
        },
        "$@key-type": {
          "eltype": "leaf",
          "description": "The type of the server private key.",
          "config": true,
          "status": "current",
          "mandatory": true,
          "type": "enumeration",
          "enumval": [
            "DSA",
            "RSA"
          ],
          "iskey": false
        }
      },
      "trusted-ca-certs": {
        "trusted-ca-cert": [
          "MIID7TCCAtWgAwIBAgIJAMtE1NGAR5KoMA0GCSqGSIb3DQEBBQUAMIGMMQswCQYD\nVQQGEwJDWjEWMBQGA1UECAwNU291dGggTW9yYXZpYTENMAsGA1UEBwwEQnJubzEP\nMA0GA1UECgwGQ0VTTkVUMQwwCgYDVQQLDANUTUMxEzARBgNVBAMMCmV4YW1wbGUg\nQ0ExIjAgBgkqhkiG9w0BCQEWE2V4YW1wbGVjYUBsb2NhbGhvc3QwHhcNMTQwNzI0\nMTQxOTAyWhcNMjQwNzIxMTQxOTAyWjCBjDELMAkGA1UEBhMCQ1oxFjAUBgNVBAgM\nDVNvdXRoIE1vcmF2aWExDTALBgNVBAcMBEJybm8xDzANBgNVBAoMBkNFU05FVDEM\nMAoGA1UECwwDVE1DMRMwEQYDVQQDDApleGFtcGxlIENBMSIwIAYJKoZIhvcNAQkB\nFhNleGFtcGxlY2FAbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\nCgKCAQEArD3TDHPAMT2Z84orK4lMlarbgooIUCcRZyLe+QM+8KY8Hn+mGaxPEOTS\nL3ywszqefB\/Utm2hPKLHX684iRC14ID9WDGHxPjvoPArhgFhfV+qnPfxKTgxZC12\nuOj4u1V9y+SkTCocFbRfXVBGpojrBuDHXkDMDEWNvr8\/52YCv7bGaiBwUHolcLCU\nbmtKILCG0RNJyTaJpXQdAeq5Z1SJotpbfYFFtAXB32hVoLug1dzl2tjG9sb1wq3Q\naDExcbC5w6P65qOkNoyym9ne6QlQagCqVDyFn3vcqkRaTjvZmxauCeUxXgJoXkyW\ncm0lM1KMHdoTArmchw2Dz0yHHSyDAQIDAQABo1AwTjAdBgNVHQ4EFgQUc1YQIqjZ\nsHVwlea0AB4N+ilNI2gwHwYDVR0jBBgwFoAUc1YQIqjZsHVwlea0AB4N+ilNI2gw\nDAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQUFAAOCAQEAI\/1KH60qnw9Xs2RGfi0\/\nIKf5EynXt4bQX8EIyVKwSkYKe04zZxYfLIl\/Q2HOPYoFmm3daj5ddr0ZS1i4p4fT\nUhstjsYWvXs3W\/HhVmFUslakkn3PrswhP77fCk6eEJLxdfyJ1C7Uudq2m1isZbKi\nh+XF0mG1LxJaDMocSz4eAya7M5brwjy8DoOmA1TnLQFCVcpn+sCr7VC4wE\/JqxyV\nhBCk\/MuGqqM3B1j90bGFZ112ZOecyE0EDSr6IbiRBtmeNbEwOFjKXhNLYdxpBZ9D\n8A\/368OckZkCrVLGuJNxK9UwCVTe8IhotHUqU9EqFDmxdV8oIdU\/OzUwwNPA\/Bd\/\n9g=="
        ],
        "$@trusted-ca-cert": {
          "eltype": "leaf-list",
          "description": "The binary certificate structure (DER) encoded\n in base64.",
          "config": true,
          "status": "current",
          "mandatory": false,
          "type": "binary"
        }
      },
      "cert-maps": {
        "cert-to-name": [
          {
            "id": 1,
            "fingerprint": "02:E9:38:1F:F6:8B:62:DE:0A:0B:C5:03:81:A8:03:49:A0:00:7F:8B:F3",
            "map-type": "ietf-x509-cert-to-name:specified",
            "name": "default_ca",
            "$@id": {
              "eltype": "leaf",
              "description": "The id specifies the order in which the entries in the\ncert-to-name list are searched.  Entries with lower\nnumbers are searched first.",
              "reference": "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNID",
              "config": true,
              "status": "current",
              "mandatory": false,
              "type": "uint32",
              "iskey": true
            },
            "$@fingerprint": {
              "eltype": "leaf",
              "description": "Specifies a value with which the fingerprint of the\ncertificate presented by the peer is compared.  If the\nfingerprint of the certificate presented by the peer does\nnot match the fingerprint configured, then the entry is\nskipped and the search for a match continues.",
              "reference": "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNFingerprint",
              "config": true,
              "status": "current",
              "mandatory": true,
              "type": "ietf-x509-cert-to-name:tls-fingerprint",
              "typedef": {
                "description": "A fingerprint value that can be used to uniquely reference\nother data of potentially arbitrary length.\n\nAn tls-fingerprint value is composed of a 1-octet hashing\nalgorithm identifier followed by the fingerprint value.  The\nfirst octet value identifying the hashing algorithm is taken\nfrom the IANA TLS HashAlgorithm Registry (RFC 5246).  The\nremaining octets are filled using the results of the hashing\nalgorithm.",
                "reference": "SNMP-TLS-TM-MIB.SnmpTLSFingerprint",
                "status": "current",
                "type": "ietf-yang-types:hex-string",
                "typedef": {
                  "description": "A hexadecimal string with octets represented as hex digits\nseparated by colons.  The canonical representation uses\nlowercase characters.",
                  "status": "current",
                  "type": "string",
                  "pattern": [
                    "([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?"
                  ]
                }
              },
              "iskey": false
            },
            "$@map-type": {
              "eltype": "leaf",
              "description": "Specifies the algorithm used to map the certificate\npresented by the peer to a name.\n\nMappings that need additional configuration objects should\nuse the 'when' statement to make them conditional based on\nthe 'map-type'.",
              "reference": "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNMapType",
              "config": true,
              "status": "current",
              "mandatory": true,
              "type": "identityref",
              "identityval": [
                "cert-to-name",
                "specified",
                "san-rfc822-name",
                "san-dns-name",
                "san-ip-address",
                "san-any",
                "common-name"
              ],
              "iskey": false
            },
            "$@name": {
              "eltype": "leaf",
              "description": "Directly specifies the NETCONF username when the\n'map-type' is 'specified'.",
              "reference": "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNData",
              "config": true,
              "status": "current",
              "mandatory": true,
              "type": "string",
              "when": "..\/map-type = 'ietf-x509-cert-to-name:specified'",
              "iskey": false
            }
          }
        ],
        "$@cert-to-name": {
          "eltype": "list",
          "description": "This list defines how certificates are mapped to names.\nThe name is derived by considering each cert-to-name\nlist entry in order. The cert-to-name entry's fingerprint\ndetermines whether the list entry is a match:\n\n1) If the cert-to-name list entry's fingerprint value\n   matches that of the presented certificate, then consider\n   the list entry as a successful match.\n\n2) If the cert-to-name list entry's fingerprint value\n   matches that of a locally held copy of a trusted CA\n   certificate, and that CA certificate was part of the CA\n   certificate chain to the presented certificate, then\n   consider the list entry as a successful match.\n\nOnce a matching cert-to-name list entry has been found, the\nmap-type is used to determine how the name associated with\nthe certificate should be determined.  See the map-type\nleaf's description for details on determining the name value.\nIf it is impossible to determine a name from the cert-to-name\nlist entry's data combined with the data presented in the\ncertificate, then additional cert-to-name list entries MUST\nbe searched looking for another potential match.\n\nSecurity administrators are encouraged to make use of\ncertificates with subjectAltName fields that can be mapped to\nnames so that a single root CA certificate can allow all\nchild certificate's subjectAltName to map directly to a name\nvia a 1:1 transformation.",
          "reference": "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNEntry",
          "config": true,
          "status": "current",
          "mandatory": false,
          "keys": [
            "id"
          ]
        }
      },
      "$@server-cert": {
        "eltype": "leaf",
        "description": "Server certificate (in base64-encoded DER) presented to clients.",
        "config": true,
        "status": "current",
        "mandatory": false,
        "type": "binary",
        "iskey": false
      },
      "$@server-key": {
        "eltype": "container",
        "config": true,
        "status": "current",
        "mandatory": false,
        "children": [
          "key-data",
          "key-type"
        ]
      },
      "$@trusted-ca-certs": {
        "eltype": "container",
        "description": "A list of Certificate Authority (CA) certificates that a\nNETCONF server can use to authenticate a NETCONF client's\ncertificate. A client's certificate is authenticated if\nits Issuer matches one of the configured trusted CA\ncertificates.",
        "config": true,
        "status": "current",
        "mandatory": false,
        "children": [
          "trusted-ca-cert"
        ]
      },
      "$@cert-maps": {
        "eltype": "container",
        "description": "The cert-maps container is used by a NETCONF server to\nmap the NETCONF client's presented X.509 certificate to\na NETCONF username.\n\nIf no matching and valid cert-to-name list entry can be\nfound, then the NETCONF server MUST close the connection,\nand MUST NOT accept NETCONF messages over it.",
        "config": true,
        "status": "current",
        "mandatory": false
      }
    },
    "$@tls": {
      "eltype": "container",
      "description": "Netopeer TLS options.",
      "config": true,
      "status": "current",
      "mandatory": false,
      "children": [
        "server-cert",
        "server-key",
        "trusted-ca-certs",
        "trusted-client-certs",
        "crl-dir",
        "cert-maps"
      ]
    }
  },
  "ietf-netconf-monitoring:netconf-state": {
    "capabilities": {
      "capability": [
        "urn:ietf:params:netconf:base:1.0",
        "urn:ietf:params:netconf:base:1.1",
        "urn:ietf:params:netconf:capability:writable-running:1.0",
        "urn:ietf:params:netconf:capability:candidate:1.0",
        "urn:ietf:params:netconf:capability:startup:1.0",
        "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        "urn:ietf:params:netconf:capability:interleave:1.0",
        "urn:ietf:params:netconf:capability:notification:1.0",
        "urn:ietf:params:netconf:capability:validate:1.0",
        "urn:ietf:params:netconf:capability:validate:1.1",
        "urn:ietf:params:netconf:capability:with-defaults:1.0?basic-mode=explicit&also-supported=report-all,report-all-tagged,trim,explicit",
        "urn:ietf:params:netconf:capability:url:1.0?scheme=scp,file",
        "urn:cesnet:tmc:netopeer:1.0?module=netopeer-cfgnetopeer&revision=2015-05-19&features=ssh,tls,dynamic-modules",
        "urn:ietf:params:xml:ns:yang:ietf-netconf-server?module=ietf-netconf-server&revision=2014-01-24&features=ssh,inbound-ssh,outbound-ssh,tls,inbound-tls,outbound-tls",
        "urn:ietf:params:xml:ns:yang:ietf-x509-cert-to-name?module=ietf-x509-cert-to-name&revision=2013-03-26",
        "urn:ietf:params:xml:ns:yang:ietf-netconf-acm?module=ietf-netconf-acm&revision=2012-02-22",
        "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults?module=ietf-netconf-with-defaults&revision=2010-06-09",
        "urn:ietf:params:xml:ns:netconf:notification:1.0?module=notifications&revision=2008-07-14",
        "urn:ietf:params:xml:ns:netmod:notification?module=nc-notifications&revision=2008-07-14",
        "urn:ietf:params:xml:ns:yang:ietf-netconf-notifications?module=ietf-netconf-notifications&revision=2012-02-06",
        "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring?module=ietf-netconf-monitoring&revision=2010-10-04",
        "urn:ietf:params:xml:ns:netconf:base:1.0?module=ietf-netconf&revision=2011-03-08&features=writable-running,candidate,rollback-on-error,validate,startup,url",
        "urn:ietf:params:xml:ns:yang:ietf-yang-types?module=ietf-yang-types&revision=2013-07-15",
        "urn:ietf:params:xml:ns:yang:ietf-inet-types?module=ietf-inet-types&revision=2013-07-15"
      ],
      "$@capability": {
        "eltype": "leaf-list",
        "description": "List of NETCONF capabilities supported by the server.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-inet-types:uri",
        "typedef": {
          "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
          "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
          "status": "current",
          "type": "string"
        }
      }
    },
    "datastores": {
      "datastore": [
        {
          "name": "running",
          "$@name": {
            "eltype": "leaf",
            "description": "Name of the datastore associated with this list entry.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "netconf-datastore-type",
            "typedef": {
              "description": "Enumeration of possible NETCONF datastore types.",
              "reference": "RFC 4741: NETCONF Configuration Protocol",
              "status": "current",
              "type": "enumeration",
              "enumval": [
                "running",
                "candidate",
                "startup"
              ]
            },
            "iskey": true
          }
        },
        {
          "name": "startup",
          "$@name": {
            "eltype": "leaf",
            "description": "Name of the datastore associated with this list entry.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "netconf-datastore-type",
            "typedef": {
              "description": "Enumeration of possible NETCONF datastore types.",
              "reference": "RFC 4741: NETCONF Configuration Protocol",
              "status": "current",
              "type": "enumeration",
              "enumval": [
                "running",
                "candidate",
                "startup"
              ]
            },
            "iskey": true
          }
        },
        {
          "name": "candidate",
          "$@name": {
            "eltype": "leaf",
            "description": "Name of the datastore associated with this list entry.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "netconf-datastore-type",
            "typedef": {
              "description": "Enumeration of possible NETCONF datastore types.",
              "reference": "RFC 4741: NETCONF Configuration Protocol",
              "status": "current",
              "type": "enumeration",
              "enumval": [
                "running",
                "candidate",
                "startup"
              ]
            },
            "iskey": true
          }
        }
      ],
      "$@datastore": {
        "eltype": "list",
        "description": "List of NETCONF configuration datastores supported by\nthe NETCONF server and related information.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "keys": [
          "name"
        ]
      }
    },
    "sessions": {
      "session": [
        {
          "session-id": 8,
          "transport": "netconf-ssh",
          "username": "vasko",
          "source-host": "UNKNOWN",
          "login-time": "0000-01-01T00:00:00Z",
          "in-rpcs": 13,
          "in-bad-rpcs": 0,
          "out-rpc-errors": 0,
          "out-notifications": 0,
          "$@session-id": {
            "eltype": "leaf",
            "description": "Unique identifier for the session.  This value is the\nNETCONF session identifier, as defined in RFC 4741.",
            "reference": "RFC 4741: NETCONF Configuration Protocol",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "uint32",
            "range": "1..max",
            "iskey": true
          },
          "$@transport": {
            "eltype": "leaf",
            "description": "Identifies the transport for each session, e.g.,\n'netconf-ssh', 'netconf-soap', etc.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "identityref",
            "identityval": [
              "transport",
              "netconf-ssh",
              "netconf-soap-over-beep",
              "netconf-soap-over-https",
              "netconf-beep",
              "netconf-tls"
            ],
            "iskey": false
          },
          "$@username": {
            "eltype": "leaf",
            "description": "The username is the client identity that was authenticated\nby the NETCONF transport protocol.  The algorithm used to\nderive the username is NETCONF transport protocol specific\nand in addition specific to the authentication mechanism\nused by the NETCONF transport protocol.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "string",
            "iskey": false
          },
          "$@source-host": {
            "eltype": "leaf",
            "description": "Host identifier of the NETCONF client.  The value\nreturned is implementation specific (e.g., hostname,\nIPv4 address, IPv6 address)",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-inet-types:host",
            "typedef": {
              "description": "The host type represents either an IP address or a DNS\ndomain name.",
              "status": "current",
              "type": "union",
              "types": [
                {
                  "type": "ip-address",
                  "typedef": {
                    "description": "The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.",
                    "reference": "RFC 4007: IPv6 Scoped Address Architecture",
                    "status": "current",
                    "type": "union",
                    "types": [
                      {
                        "type": "ipv4-address",
                        "typedef": {
                          "description": "The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat",
                          "status": "current",
                          "type": "string",
                          "pattern": [
                            "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                          ]
                        }
                      },
                      {
                        "type": "ipv6-address",
                        "typedef": {
                          "description": "The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\n\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.",
                          "reference": "RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n     Representation",
                          "status": "current",
                          "type": "string",
                          "pattern": [
                            "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?",
                            "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "type": "domain-name",
                  "typedef": {
                    "description": "The domain-name type represents a DNS domain name.  The\nname SHOULD be fully qualified whenever possible.\n\nInternet domain names are only loosely specified.  Section\n3.5 of RFC 1034 recommends a syntax (modified in Section\n2.1 of RFC 1123).  The pattern above is intended to allow\nfor current practice in domain name use, and some possible\nfuture expansion.  It is designed to hold various types of\ndomain names, including names used for A or AAAA records\n(host names) and other records, such as SRV records.  Note\nthat Internet host names have a stricter syntax (described\nin RFC 952) than the DNS recommendations in RFCs 1034 and\n1123, and that systems that want to store host names in\nschema nodes using the domain-name type are recommended to\nadhere to this stricter standard to ensure interoperability.\n\nThe encoding of DNS names in the DNS protocol is limited\nto 255 characters.  Since the encoding consists of labels\nprefixed by a length bytes and there is a trailing NULL\nbyte, only 253 characters can appear in the textual dotted\nnotation.\n\nThe description clause of schema nodes using the domain-name\ntype MUST describe when and how these names are resolved to\nIP addresses.  Note that the resolution of a domain-name value\nmay require to query multiple DNS records (e.g., A for IPv4\nand AAAA for IPv6).  The order of the resolution process and\nwhich DNS record takes precedence can either be defined\nexplicitly or may depend on the configuration of the\nresolver.\n\nDomain-name values use the US-ASCII encoding.  Their canonical\nformat uses lowercase US-ASCII characters.  Internationalized\ndomain names MUST be A-labels as per RFC 5890.",
                    "reference": "RFC  952: DoD Internet Host Table Specification\nRFC 1034: Domain Names - Concepts and Facilities\nRFC 1123: Requirements for Internet Hosts -- Application\n     and Support\nRFC 2782: A DNS RR for specifying the location of services\n     (DNS SRV)\nRFC 5890: Internationalized Domain Names in Applications\n     (IDNA): Definitions and Document Framework",
                    "status": "current",
                    "type": "string",
                    "length": "1..253",
                    "pattern": [
                      "((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\."
                    ]
                  }
                }
              ]
            },
            "iskey": false
          },
          "$@login-time": {
            "eltype": "leaf",
            "description": "Time at the server at which the session was established.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-yang-types:date-and-time",
            "typedef": {
              "description": "The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n time zone (see RFC 3339) while -00:00 and +00:00 and Z\n all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n differs from the canonical format used by the dateTime XML\n schema type, which requires all times to be in UTC using\n the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.",
              "reference": "RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition",
              "status": "current",
              "type": "string",
              "pattern": [
                "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})"
              ]
            },
            "iskey": false
          },
          "$@in-rpcs": {
            "eltype": "leaf",
            "description": "Number of correct <rpc> messages received.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-yang-types:zero-based-counter32",
            "typedef": {
              "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
              "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
              "status": "current",
              "type": "counter32",
              "typedef": {
                "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
                "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
                "status": "current",
                "type": "uint32"
              },
              "default": "0"
            },
            "iskey": false
          },
          "$@in-bad-rpcs": {
            "eltype": "leaf",
            "description": "Number of messages received when an <rpc> message was expected,\nthat were not correct <rpc> messages.  This includes XML parse\nerrors and errors on the rpc layer.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-yang-types:zero-based-counter32",
            "typedef": {
              "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
              "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
              "status": "current",
              "type": "counter32",
              "typedef": {
                "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
                "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
                "status": "current",
                "type": "uint32"
              },
              "default": "0"
            },
            "iskey": false
          },
          "$@out-rpc-errors": {
            "eltype": "leaf",
            "description": "Number of <rpc-reply> messages sent that contained an\n<rpc-error> element.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-yang-types:zero-based-counter32",
            "typedef": {
              "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
              "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
              "status": "current",
              "type": "counter32",
              "typedef": {
                "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
                "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
                "status": "current",
                "type": "uint32"
              },
              "default": "0"
            },
            "iskey": false
          },
          "$@out-notifications": {
            "eltype": "leaf",
            "description": "Number of <notification> messages sent.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-yang-types:zero-based-counter32",
            "typedef": {
              "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
              "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
              "status": "current",
              "type": "counter32",
              "typedef": {
                "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
                "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
                "status": "current",
                "type": "uint32"
              },
              "default": "0"
            },
            "iskey": false
          }
        }
      ],
      "$@session": {
        "eltype": "list",
        "description": "All NETCONF sessions managed by the NETCONF server\nMUST be reported in this list.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "keys": [
          "session-id"
        ]
      }
    },
    "schemas": {
      "schema": [
        {
          "identifier": "netopeer-cfgnetopeer",
          "version": "2015-05-19",
          "format": "yin",
          "namespace": "urn:cesnet:tmc:netopeer:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "netopeer-cfgnetopeer",
          "version": "2015-05-19",
          "format": "yang",
          "namespace": "urn:cesnet:tmc:netopeer:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-server",
          "version": "2014-01-24",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-server",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-server",
          "version": "2014-01-24",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-server",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-x509-cert-to-name",
          "version": "2013-03-26",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-x509-cert-to-name",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-x509-cert-to-name",
          "version": "2013-03-26",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-x509-cert-to-name",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-acm",
          "version": "2012-02-22",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-acm",
          "version": "2012-02-22",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-with-defaults",
          "version": "2010-06-09",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-with-defaults",
          "version": "2010-06-09",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "notifications",
          "version": "2008-07-14",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:netconf:notification:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "notifications",
          "version": "2008-07-14",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:netconf:notification:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "nc-notifications",
          "version": "2008-07-14",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:netmod:notification",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "nc-notifications",
          "version": "2008-07-14",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:netmod:notification",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-notifications",
          "version": "2012-02-06",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-notifications",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-notifications",
          "version": "2012-02-06",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-notifications",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-monitoring",
          "version": "2010-10-04",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf-monitoring",
          "version": "2010-10-04",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf",
          "version": "2011-03-08",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-netconf",
          "version": "2011-03-08",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-yang-types",
          "version": "2013-07-15",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-types",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-yang-types",
          "version": "2013-07-15",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-types",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-inet-types",
          "version": "2013-07-15",
          "format": "yin",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-inet-types",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        },
        {
          "identifier": "ietf-inet-types",
          "version": "2013-07-15",
          "format": "yang",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-inet-types",
          "location": [
            "NETCONF"
          ],
          "$@identifier": {
            "eltype": "leaf",
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@version": {
            "eltype": "leaf",
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "string",
            "iskey": true
          },
          "$@format": {
            "eltype": "leaf",
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "identityref",
            "identityval": [
              "schema-format",
              "xsd",
              "yang",
              "yin",
              "rng",
              "rnc"
            ],
            "iskey": true
          },
          "$@namespace": {
            "eltype": "leaf",
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "ietf-inet-types:uri",
            "typedef": {
              "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
              "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
              "status": "current",
              "type": "string"
            },
            "iskey": false
          },
          "$@location": {
            "eltype": "leaf-list",
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF').",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "union",
            "types": [
              {
                "type": "enumeration",
                "enumval": [
                  "NETCONF"
                ]
              },
              {
                "type": "ietf-inet-types:uri",
                "typedef": {
                  "description": "The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.",
                  "reference": "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C\/IETF URI Planning Interest\n     Group: Uniform Resource Identifiers (URIs), URLs,\n     and Uniform Resource Names (URNs): Clarifications\n     and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n     Identifiers (URIs)",
                  "status": "current",
                  "type": "string"
                }
              }
            ]
          }
        }
      ],
      "$@schema": {
        "eltype": "list",
        "description": "List of data model schemas supported by the server.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "keys": [
          "identifier",
          "version",
          "format"
        ]
      }
    },
    "statistics": {
      "netconf-start-time": "2015-11-23T08:31:36Z",
      "in-bad-hellos": 0,
      "in-sessions": 8,
      "dropped-sessions": 6,
      "in-rpcs": 105,
      "in-bad-rpcs": 6,
      "out-rpc-errors": 0,
      "out-notifications": 0,
      "$@netconf-start-time": {
        "eltype": "leaf",
        "description": "Date and time at which the management subsystem was\nstarted.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:date-and-time",
        "typedef": {
          "description": "The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n time zone (see RFC 3339) while -00:00 and +00:00 and Z\n all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n differs from the canonical format used by the dateTime XML\n schema type, which requires all times to be in UTC using\n the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.",
          "reference": "RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition",
          "status": "current",
          "type": "string",
          "pattern": [
            "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})"
          ]
        },
        "iskey": false
      },
      "$@in-bad-hellos": {
        "eltype": "leaf",
        "description": "Number of sessions silently dropped because an\ninvalid <hello> message was received.  This includes <hello>\nmessages with a 'session-id' attribute, bad namespace, and\nbad capability declarations.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@in-sessions": {
        "eltype": "leaf",
        "description": "Number of sessions started.  This counter is incremented\nwhen a <hello> message with a <session-id> is sent.\n\n'in-sessions' - 'in-bad-hellos' =\n   'number of correctly started netconf sessions'",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@dropped-sessions": {
        "eltype": "leaf",
        "description": "Number of sessions that were abnormally terminated, e.g.,\ndue to idle timeout or transport close.  This counter is not\nincremented when a session is properly closed by a\n<close-session> operation, or killed by a <kill-session>\noperation.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@in-rpcs": {
        "eltype": "leaf",
        "description": "Number of correct <rpc> messages received.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@in-bad-rpcs": {
        "eltype": "leaf",
        "description": "Number of messages received when an <rpc> message was expected,\nthat were not correct <rpc> messages.  This includes XML parse\nerrors and errors on the rpc layer.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@out-rpc-errors": {
        "eltype": "leaf",
        "description": "Number of <rpc-reply> messages sent that contained an\n<rpc-error> element.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      },
      "$@out-notifications": {
        "eltype": "leaf",
        "description": "Number of <notification> messages sent.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "type": "ietf-yang-types:zero-based-counter32",
        "typedef": {
          "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
          "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
          "status": "current",
          "type": "counter32",
          "typedef": {
            "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
            "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
            "status": "current",
            "type": "uint32"
          },
          "default": "0"
        },
        "iskey": false
      }
    },
    "$@capabilities": {
      "eltype": "container",
      "description": "Contains the list of NETCONF capabilities supported by the\nserver.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "capability"
      ]
    },
    "$@datastores": {
      "eltype": "container",
      "description": "Contains the list of NETCONF configuration datastores.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "datastore"
      ]
    },
    "$@sessions": {
      "eltype": "container",
      "description": "The sessions container includes session-specific data for\nNETCONF management sessions.  The session list MUST include\nall currently active NETCONF sessions.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "session"
      ]
    },
    "$@schemas": {
      "eltype": "container",
      "description": "Contains the list of data model schemas supported by the\nserver.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "schema"
      ]
    },
    "$@statistics": {
      "eltype": "container",
      "description": "Statistical data pertaining to the NETCONF server.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "netconf-start-time",
        "in-bad-hellos",
        "in-sessions",
        "dropped-sessions"
      ]
    }
  },
  "nc-notifications:netconf": {
    "streams": {
      "stream": [
        {
          "name": "NETCONF",
          "description": "NETCONF Base Notifications",
          "replaySupport": true,
          "replayLogCreationTime": "2014-09-22T09:25:33Z",
          "$@name": {
            "eltype": "leaf",
            "description": "The name of the event stream. If this is the default\nNETCONF stream, this must have the value 'NETCONF'.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "notifications:streamNameType",
            "typedef": {
              "description": "The name of an event stream.",
              "status": "current",
              "type": "string"
            },
            "iskey": true
          },
          "$@description": {
            "eltype": "leaf",
            "description": "A description of the event stream, including such\ninformation as the type of events that are sent over\nthis stream.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "string",
            "iskey": false
          },
          "$@replaySupport": {
            "eltype": "leaf",
            "description": "A description of the event stream, including such\ninformation as the type of events that are sent over\nthis stream.",
            "config": false,
            "status": "current",
            "mandatory": true,
            "type": "bool",
            "iskey": false
          },
          "$@replayLogCreationTime": {
            "eltype": "leaf",
            "description": "The timestamp of the creation of the log used to support\nthe replay function on this stream. Note that this might\nbe earlier then the earliest available notification in\nthe log. This object is updated if the log resets for \nsome reason.  This object MUST be present if replay is\nsupported.",
            "config": false,
            "status": "current",
            "mandatory": false,
            "type": "ietf-yang-types:date-and-time",
            "typedef": {
              "description": "The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n time zone (see RFC 3339) while -00:00 and +00:00 and Z\n all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n differs from the canonical format used by the dateTime XML\n schema type, which requires all times to be in UTC using\n the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.",
              "reference": "RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition",
              "status": "current",
              "type": "string",
              "pattern": [
                "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})"
              ]
            },
            "iskey": false
          }
        }
      ],
      "$@stream": {
        "eltype": "list",
        "description": "Stream name, description and other information.",
        "config": false,
        "status": "current",
        "mandatory": false,
        "min-elements": 1,
        "keys": [
          "name"
        ]
      }
    },
    "$@streams": {
      "eltype": "container",
      "description": "The list of event streams supported by the system. When\na query is issued, the returned set of streams is \ndetermined based on user privileges.",
      "config": false,
      "status": "current",
      "mandatory": false,
      "children": [
        "stream"
      ]
    }
  },
  "ietf-netconf-acm:nacm": {
    "rule-list": [
      {
        "name": "almighty",
        "group": [
          "almighty"
        ],
        "rule": [
          {
            "name": "almighty",
            "module-name": "*",
            "access-operations": "*",
            "action": "permit",
            "$@name": {
              "eltype": "leaf",
              "description": "Arbitrary name assigned to the rule.",
              "config": true,
              "status": "current",
              "mandatory": false,
              "ext": "default-deny-all",
              "type": "string",
              "length": "1..max",
              "iskey": true
            },
            "$@module-name": {
              "eltype": "leaf",
              "description": "Name of the module associated with this rule.\n\nThis leaf matches if it has the value '*' or if the\nobject being accessed is defined in the module with the\nspecified module name.",
              "config": true,
              "status": "current",
              "mandatory": false,
              "ext": "default-deny-all",
              "type": "union",
              "types": [
                {
                  "type": "matchall-string-type",
                  "typedef": {
                    "description": "The string containing a single asterisk '*' is used\nto conceptually represent all possible values\nfor the particular leaf using this data type.",
                    "status": "current",
                    "type": "string",
                    "pattern": [
                      "\\*"
                    ]
                  }
                },
                {
                  "type": "string"
                }
              ],
              "default": "*",
              "iskey": false
            },
            "$@access-operations": {
              "eltype": "leaf",
              "description": "Access operations associated with this rule.\n\nThis leaf matches if it has the value '*' or if the\nbit corresponding to the requested operation is set.",
              "config": true,
              "status": "current",
              "mandatory": false,
              "ext": "default-deny-all",
              "type": "union",
              "types": [
                {
                  "type": "matchall-string-type",
                  "typedef": {
                    "description": "The string containing a single asterisk '*' is used\nto conceptually represent all possible values\nfor the particular leaf using this data type.",
                    "status": "current",
                    "type": "string",
                    "pattern": [
                      "\\*"
                    ]
                  }
                },
                {
                  "type": "access-operations-type",
                  "typedef": {
                    "description": "NETCONF Access Operation.",
                    "status": "current",
                    "type": "bits",
                    "bits": [
                      {
                        "name": "create",
                        "position": 0
                      },
                      {
                        "name": "read",
                        "position": 1
                      },
                      {
                        "name": "update",
                        "position": 2
                      },
                      {
                        "name": "delete",
                        "position": 3
                      },
                      {
                        "name": "exec",
                        "position": 4
                      }
                    ]
                  }
                }
              ],
              "default": "*",
              "iskey": false
            },
            "$@action": {
              "eltype": "leaf",
              "description": "The access control action associated with the\nrule.  If a rule is determined to match a\nparticular request, then this object is used\nto determine whether to permit or deny the\nrequest.",
              "config": true,
              "status": "current",
              "mandatory": true,
              "ext": "default-deny-all",
              "type": "action-type",
              "typedef": {
                "description": "Action taken by the server when a particular\nrule matches.",
                "status": "current",
                "type": "enumeration",
                "enumval": [
                  "permit",
                  "deny"
                ]
              },
              "iskey": false
            }
          }
        ],
        "$@name": {
          "eltype": "leaf",
          "description": "Arbitrary name assigned to the rule-list.",
          "config": true,
          "status": "current",
          "mandatory": false,
          "ext": "default-deny-all",
          "type": "string",
          "length": "1..max",
          "iskey": true
        },
        "$@group": {
          "eltype": "leaf-list",
          "description": "List of administrative groups that will be\nassigned the associated access rights\ndefined by the 'rule' list.\n\nThe string '*' indicates that all groups apply to the\nentry.",
          "config": true,
          "status": "current",
          "mandatory": false,
          "ext": "default-deny-all",
          "type": "union",
          "types": [
            {
              "type": "matchall-string-type",
              "typedef": {
                "description": "The string containing a single asterisk '*' is used\nto conceptually represent all possible values\nfor the particular leaf using this data type.",
                "status": "current",
                "type": "string",
                "pattern": [
                  "\\*"
                ]
              }
            },
            {
              "type": "group-name-type",
              "typedef": {
                "description": "Name of administrative group to which\nusers can be assigned.",
                "status": "current",
                "type": "string",
                "length": "1..max",
                "pattern": [
                  "[^\\*].*"
                ]
              }
            }
          ]
        },
        "$@rule": {
          "eltype": "list",
          "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines if access is granted\nor not.",
          "config": true,
          "status": "current",
          "mandatory": false,
          "ext": "default-deny-all",
          "keys": [
            "name"
          ]
        }
      }
    ],
    "groups": {
      "group": [
        {
          "name": "almighty",
          "user-name": [
            "vasko"
          ],
          "$@name": {
            "eltype": "leaf",
            "description": "Group name associated with this entry.",
            "config": true,
            "status": "current",
            "mandatory": false,
            "ext": "default-deny-all",
            "type": "group-name-type",
            "typedef": {
              "description": "Name of administrative group to which\nusers can be assigned.",
              "status": "current",
              "type": "string",
              "length": "1..max",
              "pattern": [
                "[^\\*].*"
              ]
            },
            "iskey": true
          },
          "$@user-name": {
            "eltype": "leaf-list",
            "description": "Each entry identifies the username of\na member of the group associated with\nthis entry.",
            "config": true,
            "status": "current",
            "mandatory": false,
            "ext": "default-deny-all",
            "type": "user-name-type",
            "typedef": {
              "description": "General Purpose Username string.",
              "status": "current",
              "type": "string",
              "length": "1..max"
            }
          }
        }
      ],
      "$@group": {
        "eltype": "list",
        "description": "One NACM Group Entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "config": true,
        "status": "current",
        "mandatory": false,
        "ext": "default-deny-all",
        "keys": [
          "name"
        ]
      }
    },
    "denied-operations": 0,
    "denied-data-writes": 0,
    "denied-notifications": 0,
    "$@rule-list": {
      "eltype": "list",
      "description": "An ordered collection of access control rules.",
      "config": true,
      "status": "current",
      "mandatory": false,
      "ext": "default-deny-all",
      "keys": [
        "name"
      ]
    },
    "$@groups": {
      "eltype": "container",
      "description": "NETCONF Access Control Groups.",
      "config": true,
      "status": "current",
      "mandatory": false,
      "ext": "default-deny-all",
      "children": [
        "group"
      ]
    },
    "$@denied-operations": {
      "eltype": "leaf",
      "description": "Number of times since the server last restarted that a\nprotocol operation request was denied.",
      "config": false,
      "status": "current",
      "mandatory": true,
      "ext": "default-deny-all",
      "type": "ietf-yang-types:zero-based-counter32",
      "typedef": {
        "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
        "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
        "status": "current",
        "type": "counter32",
        "typedef": {
          "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
          "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
          "status": "current",
          "type": "uint32"
        },
        "default": "0"
      },
      "iskey": false
    },
    "$@denied-data-writes": {
      "eltype": "leaf",
      "description": "Number of times since the server last restarted that a\nprotocol operation request to alter\na configuration datastore was denied.",
      "config": false,
      "status": "current",
      "mandatory": true,
      "ext": "default-deny-all",
      "type": "ietf-yang-types:zero-based-counter32",
      "typedef": {
        "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
        "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
        "status": "current",
        "type": "counter32",
        "typedef": {
          "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
          "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
          "status": "current",
          "type": "uint32"
        },
        "default": "0"
      },
      "iskey": false
    },
    "$@denied-notifications": {
      "eltype": "leaf",
      "description": "Number of times since the server last restarted that\na notification was dropped for a subscription because\naccess to the event type was denied.",
      "config": false,
      "status": "current",
      "mandatory": true,
      "ext": "default-deny-all",
      "type": "ietf-yang-types:zero-based-counter32",
      "typedef": {
        "description": "The zero-based-counter32 type represents a counter32\nthat has the defined 'initial' value zero.\n\nA schema node of this type will be set to zero (0) on creation\nand will thereafter increase monotonically until it reaches\na maximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nProvided that an application discovers a new schema node\nof this type within the minimum time to wrap, it can use the\n'initial' value as a delta.  It is important for a management\nstation to be aware of this minimum time and the actual time\nbetween polls, and to discard data if the actual time is too\nlong or there is no defined minimum time.\n\nIn the value set and its semantics, this type is equivalent\nto the ZeroBasedCounter32 textual convention of the SMIv2.",
        "reference": "RFC 4502: Remote Network Monitoring Management Information\n     Base Version 2",
        "status": "current",
        "type": "counter32",
        "typedef": {
          "description": "The counter32 type represents a non-negative integer\nthat monotonically increases until it reaches a\nmaximum value of 2^32-1 (4294967295 decimal), when it\nwraps around and starts increasing again from zero.\n\nCounters have no defined 'initial' value, and thus, a\nsingle value of a counter has (in general) no information\ncontent.  Discontinuities in the monotonically increasing\nvalue normally occur at re-initialization of the\nmanagement system, and at other times as specified in the\ndescription of a schema node using this type.  If such\nother times can occur, for example, the creation of\na schema node of type counter32 at times other than\nre-initialization, then a corresponding schema node\nshould be defined, with an appropriate type, to indicate\nthe last discontinuity.\n\nThe counter32 type should not be used for configuration\nschema nodes.  A default statement SHOULD NOT be used in\ncombination with the type counter32.\n\nIn the value set and its semantics, this type is equivalent\nto the Counter32 type of the SMIv2.",
          "reference": "RFC 2578: Structure of Management Information Version 2\n     (SMIv2)",
          "status": "current",
          "type": "uint32"
        },
        "default": "0"
      },
      "iskey": false
    }
  },
  "$@netopeer-cfgnetopeer:netopeer": {
    "eltype": "container",
    "config": true,
    "status": "current",
    "mandatory": false,
    "children": [
      "hello-timeout",
      "idle-timeout",
      "max-sessions",
      "response-time",
      "ssh",
      "tls",
      "modules"
    ]
  },
  "$@ietf-netconf-monitoring:netconf-state": {
    "eltype": "container",
    "description": "The netconf-state container is the root of the monitoring\ndata model.",
    "config": false,
    "status": "current",
    "mandatory": false,
    "children": [
      "capabilities",
      "datastores",
      "schemas",
      "sessions",
      "statistics"
    ]
  },
  "$@nc-notifications:netconf": {
    "eltype": "container",
    "description": "Top-level element in the notification namespace",
    "config": false,
    "status": "current",
    "mandatory": false,
    "children": [
      "streams"
    ]
  },
  "$@ietf-netconf-acm:nacm": {
    "eltype": "container",
    "description": "Parameters for NETCONF Access Control Model.",
    "config": true,
    "status": "current",
    "mandatory": false,
    "ext": "default-deny-all",
    "children": [
      "enable-nacm",
      "read-default",
      "write-default",
      "exec-default",
      "enable-external-groups",
      "denied-operations",
      "denied-data-writes",
      "denied-notifications",
      "groups",
      "rule-list"
    ]
  }
}
